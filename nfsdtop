#!/bin/sh
############################################################ IDENT(1)
#
# $Title: Script to generate top-like statistics for nfsd I/O $
# $Copyright: 2020 Devin Teske. All rights reserved. $
# $FrauBSD: nfsdtop/nfsdtop 2020-03-12 10:38:55 -0700 freebsdfrau $
#
############################################################ DEFAULTS

DEFAULT_INTERVAL=2 # seconds

#
# User/Group map files
#
DEFAULT_PASSWD_MAP=.nfsd.passwd
DEFAULT_GROUP_MAP=.nfsd.group

############################################################ GLOBALS

VERSION='$Version: 2.1-beta-3 $'

pgm="${0##*/}" # Program basename

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
DEBUG=					# -d
FILTER_FILE=				# -F regex
FILTER_GROUP=				# -G group
FILTER_USER=				# -U user
GROUP_MAP="$DEFAULT_GROUP_MAP"		# -P file
INTERVAL=$DEFAULT_INTERVAL		# -i sec
NO_NAMES=				# -n
NSAMPLES=				# -N num
OUTPUT_JSON=				# -j
PASSWD_MAP="$DEFAULT_PASSWD_MAP"	# -p file
RAW_VIEW=				# -r
VIEW_CLIENT=				# -c
VIEW_FILE=				# -f
VIEW_GROUP=				# -g
VIEW_SERVER=				# -s
VIEW_USER=				# -u (default)
WIDE_VIEW=				# -w

#
# Miscellaneous
#
_FILTER_GROUP=
_FILTER_USER=
INTERVAL_PROBE= # Calculated
INTERVAL_SECONDS= # Raw value for awk
VIEW=

############################################################ FUNCTIONS

die()
{
	local fmt="$1"
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@" >&2
	fi
	exit $FAILURE
}

usage()
{
	local fmt="$1"
	local optfmt="\t%-11s %s\n"

	exec >&2
	if [ "$1" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi

	printf "Usage: %s [OPTIONS]\n" "$pgm"
	printf "Options:\n"
	printf "$optfmt" "-c" "View read/write activity by client IP."
	printf "$optfmt" "-d" "Debug. Print bpftrace script and exit."
	printf "$optfmt" "-F regex" "File filter. Implies \`-f'."
	printf "$optfmt" "-f" \
		"View read/write activity by file. Implies \`-w'."
	printf "$optfmt" "-G group" "Group filter (name or id)."
	printf "$optfmt" "-g" "View read/write activity by group."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-i sec" \
		"Set interval seconds. Default $DEFAULT_INTERVAL."
	printf "$optfmt" "" "Accepts decimal point on seconds."
	printf "$optfmt" "-J" "Output most JSON data. Same as \`-jcgsu'."
	printf "$optfmt" "-j" "Output JSON formatted data."
	printf "$optfmt" "-N num" "Perform num samples and exit."
	printf "$optfmt" "-n" "Do not attempt to map uid/gid to names."
	printf "$optfmt" "-P file" "Group map file. Default \`$GROUP_MAP'."
	printf "$optfmt" "-p file" "User map file. Default \`$PASSWD_MAP'."
	printf "$optfmt" "-r" "Raw view. Do not format output of bpftrace."
	printf "$optfmt" "-s" "View read/write activity by server IP."
	printf "$optfmt" "-U group" "User filter (name or id)."
	printf "$optfmt" "-u" "View read/write activity by user (default)."
	printf "$optfmt" "-v" "Print version and exit."
	printf "$optfmt" "-w" "Wide view. Maximize width of first column."

	die
}

run_bpftrace()
{
	if [ "$DEBUG" ]; then
		cat "$@"
	else
		exec bpftrace "$@"
	fi
}

############################################################ MAIN

#
# Parse command-line options
#
while getopts cdF:fG:ghi:JjN:nP:p:rsU:uvw flag; do
	case "$flag" in
	c) VIEW=CLIENT VIEW_CLIENT=1 ;;
	d) DEBUG=1 RAW_VIEW=1 ;;
	F) VIEW=FILE VIEW_FILE=1 WIDE_VIEW=1 FILTER_FILE="$OPTARG" ;;
	f) VIEW=FILE VIEW_FILE=1 WIDE_VIEW=1 ;;
	G) FILTER_GROUP="$OPTARG" ;;
	g) VIEW=GROUP VIEW_GROUP=1 ;;
	i) INTERVAL="$OPTARG" ;;
	J) OUTPUT_JSON=1 \
		VIEW_CLIENT=1 VIEW_GROUP=1 VIEW_SERVER=1 VIEW_USER=1 ;;
	j) OUTPUT_JSON=1 ;;
	N) [ "$OPTARG" ] || usage "-N option requires an argument" # NOTREACHED
		NSAMPLES="$OPTARG" ;;
	n) NO_NAMES=1 ;;
	P) GROUP_MAP="$OPTARG" ;;
	p) PASSWD_MAP="$OPTARG" ;;
	r) RAW_VIEW=1 ;;
	s) VIEW=SERVER VIEW_SERVER=1 ;;
	U) FILTER_USER="$OPTARG" ;;
	u) VIEW=USER VIEW_USER=1 ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	w) WIDE_VIEW=1 ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Check command-line arguments
#
[ $# -eq 0 ] || usage "Too many arguments" # NOTREACHED

#
# Silently ignore previous view options unless JSON output
#
[ "$VIEW" ] || VIEW=USER VIEW_USER=1
if [ ! "$OUTPUT_JSON" ]; then
	case "$VIEW" in
	CLIENT) VIEW_FILE= VIEW_GROUP= VIEW_SERVER= VIEW_USER= ;;
	FILE) VIEW_CLIENT= VIEW_GROUP= VIEW_SERVER= VIEW_USER= ;;
	GROUP) VIEW_CLIENT= VIEW_FILE= VIEW_SERVER= VIEW_USER= ;;
	SERVER) VIEW_CLIENT= VIEW_FILE= VIEW_GROUP= VIEW_USER= ;;
	USER) VIEW_CLIENT= VIEW_FILE= VIEW_GROUP= VIEW_SERVER= ;;
	esac
fi

#
# Validate `-i sec' option
#
case "$INTERVAL" in
"") usage "missing -i argument" ;; # NOTREACHED
0) die "-i sec must be non-zero" ;;
*[!0-9.]*|*.*.*|.) die "-i argument must be a number" ;;
*.*)
	INTERVAL_SECONDS=$INTERVAL
	ms=$( echo "$INTERVAL * 1000" | bc )
	ms="${ms%%.*}"

	#
	# If, after multiplying by 1000 to convert sec to msec,
	# the leading [non-decimal] digit is either missing or zero,
	# the input was too small to produce timing of at least 1 msec
	#
	case "$ms" in
	""|0) die "-i argument must be at least 0.001" ;;
	esac

	INTERVAL_PROBE=interval:ms:$ms
	;;
*)
	INTERVAL_SECONDS=$INTERVAL
	INTERVAL_PROBE=interval:s:$INTERVAL_SECONDS
esac

#
# Validate `-N num' option
#
case "$NSAMPLES" in
0) die "-i sec must be non-zero" ;;
*[!0-9]*) die "-i argument must be a positive integer" ;;
esac

#
# Process `-G group' option
#
case "$FILTER_GROUP" in
"") : ok ;;
*[!0-9]*) # name
	_FILTER_GROUP=$( awk \
		-v sq="'" \
		-v group_map="$GROUP_MAP" \
		-v name="$FILTER_GROUP" \
	'BEGIN {
		delete gid2name
		while (getline < group_map > 0) {
			n = split($0, fields, /:/)
			name2gid[fields[1]] = fields[3]
		}
		close(group_map)
		if (name in name2gid) {
			print name2gid[name]
			exit 0
		}
		gsub(sq, "&\\\\&&", name)
		cmd = sprintf("getent group %s%s%s", sq, name, sq)
		cmd | getline group
		close(cmd)
		if (split(group, fields, /:/) >= 3) {
			print fields[3]
			exit 0
		}
		exit 1
	}' 2> /dev/null ) || die "Unknown group %s" "$FILTER_GROUP"
	FILTER_GROUP="$_FILTER_GROUP"
	;;
esac

#
# Process `-U group' option
#
case "$FILTER_USER" in
"") : ok ;;
*[!0-9]*) # name
	_FILTER_USER=$( awk \
		-v sq="'" \
		-v user_map="$PASSWD_MAP" \
		-v name="$FILTER_USER" \
	'BEGIN {
		delete uid2name
		while (getline < user_map > 0) {
			n = split($0, fields, /:/)
			name2uid[fields[1]] = fields[3]
		}
		close(user_map)
		if (name in name2uid) {
			print name2uid[name]
			exit 0
		}
		gsub(sq, "&\\\\&&", name)
		cmd = sprintf("getent passwd %s%s%s", sq, name, sq)
		cmd | getline passwd
		close(cmd)
		if (split(passwd, fields, /:/) >= 3) {
			print fields[3]
			exit 0
		}
		exit 1
	}' ) || die "Unknown user %s" "$FILTER_USER"
	FILTER_USER="$_FILTER_USER"
	;;
esac

#
# Get terminal size
#
size=$( stty size 2> /dev/null )
if [ "$size" ]; then
	cols="${size#*[$IFS]}"
	rows="${size%%[$IFS]*}"
	case "$rows$cols" in
	*[!0-9]*)
		cols=80
		rows=24
		;;
	esac
fi

#
# Trace nfsd I/O
#
export FILTER_FILE
run_bpftrace /dev/stdin <<EOF | awk \
	-v cols=$cols \
	-v group_map="$GROUP_MAP" \
	-v interval=$INTERVAL_SECONDS \
	-v no_names=${NO_NAMES:-0} \
	-v nsamples=${NSAMPLES:-0} \
	-v output_json=${OUTPUT_JSON:-0} \
	-v passwd_map="$PASSWD_MAP" \
	-v raw_view=${RAW_VIEW:-0} \
	-v rows=$rows \
	-v view="$VIEW" \
	-v wide_view=${WIDE_VIEW:-0} \
	'####################################### BEGIN

	BEGIN {
		filter_file = ENVIRON["FILTER_FILE"]
		samples_left = nsamples
		waiting = "Waiting for bpftrace to initialize ..."

		# Obtain awk pid
		(cmd = "echo $PPID") | getline apid
		close(cmd)

		# Obtain sh pid
		getline stat < (file = sprintf("/proc/%d/stat", apid))
		close(file)
		split(stat, st)
		spid = st[4]

		# Obtain bpftrace pid
		(cmd = sprintf("pgrep -P %d bpftrace", spid)) | getline bpid
		close(cmd)

		if (wide_view) {
			vsz = cols - 36 - 4 - 21 # Maximize view column
				# 36 = 3 x %12s
				#  4 = number of spaces
				# 21 = minimum bar size
		} else {
			vsz = 15 # Maximize bar column
		}

		fmt = "%-"vsz"s %12s %12s %*s|%-*s %-12s\n"
		bar_size = (cols - vsz - 36 - 4 - 1) / 2
			# 36 = 3 x %12s
			#  4 = number of spaces
			#  1 = balance odd cols
		fmtsz = vsz + 36 + 4 + int(bar_size) * 2 + 1
			# 36 = 3 x %12s
			#  4 = number of spaces
			#  1 = "|" between bars

		if (!raw_view) {
			clear_buffer()
			buffer_add_header()
			if (!output_json) {
				buffer_add(waiting "\n")
				print_buffer()
			}
			if (!no_names) load_files()
		}
	}

	######################################## FUNCTIONS

	function buffer_add(text) { BUFFER = BUFFER text }
	function print_buffer() { printf "%s", BUFFER }

	function clear_data()
	{
		delete client_keys
		delete file_keys
		delete group_keys
		delete server_keys
		delete user_keys

		nviews = 0
		delete map_views
		delete view_list

		delete map_key_read
		delete map_key_write
		delete map_view_read
		delete map_view_write
	}

	function clear_buffer()
	{
		clear_data()

		BUFFER = ""
		if (!output_json)
			buffer_add(sprintf("\033[H\033[J"))
	}

	function buffer_add_header()
	{
		if (output_json) return
		buffer_add(sprintf("Interval: %-*s %31s\n",
			fmtsz - 9 - 2 - 31,
			sprintf("%.3f", interval) "s",
			strftime("%c", systime())))
				#  9 = "Interval:"
				#  2 = number of spaces
				# 31 = %31s = date
		buffer_add(sprintf("\033[7;1m" fmt "\033[27;22m", view,
			"TOTAL", "WRITE(IN)", bar_size, "", bar_size, "",
			"READ(OUT)"))
	}

	function load_files()
	{
		delete uid2name
		while (getline < passwd_map > 0) {
			n = split($0, fields, /:/)
			uid2name[fields[3]] = fields[1]
		}
		close(passwd_map)

		delete gid2name
		while (getline < group_map > 0) {
			n = split($0, fields, /:/)
			gid2name[fields[3]] = fields[1]
		}
		close(group_map)
	}

	function load_keys(map_view,        map_key)
	{
		delete _keys
		if (map_view == "client") for (map_key in client_keys)
			_keys[map_key] = client_keys[map_key]
		else if (map_view == "file") for (map_key in file_keys)
			_keys[map_key] = file_keys[map_key]
		else if (map_view == "group") for (map_key in group_keys)
			_keys[map_key] = group_keys[map_key]
		else if (map_view == "server") for (map_key in server_keys)
			_keys[map_key] = server_keys[map_key]
		else if (map_view == "user") for (map_key in user_keys)
			_keys[map_key] = user_keys[map_key]
	}

	function parse_map()
	{
		if (!match($0, /^@[^\[]*\[/)) return 0
		map_name = substr($0, RSTART + 1, RLENGTH - 2)
		map_view = substr(map_name, 4)
		map_op = substr(map_name, 1, 2) # rd/wr

		if (!match($0, /\[.*\]:/)) return 0
		map_key = substr($0, RSTART + 1, RLENGTH - 3)
		map_value = $NF

		if (map_view == "user" || map_view == "group") {
			map_key = int(map_key)
		} else if (map_view == "file") {
			if (filter_file != "" && cred !~ filter_file) return 0
			gsub(/, /, "/", map_key)
			gsub("//+", "/", map_key)
		}

		if (!(map_view in map_views)) {
			map_views[map_view]
			view_list[++nviews] = map_view
		}
		if (map_view == "client") client_keys[map_key]
		else if (map_view == "file") file_keys[map_key]
		else if (map_view == "group") group_keys[map_key]
		else if (map_view == "server") server_keys[map_key]
		else if (map_view == "user") user_keys[map_key]

		if (map_op == "rd") {
			map_view_read[map_view] += map_value
			map_key_read[map_view, map_key] = map_value
		} else { # wr
			map_view_write[map_view] += map_value
			map_key_write[map_view, map_key] = map_value
		}

		return 1
	}

	function humanize(value,        raw, n, suffix, suffixes)
	{
		raw = value
		n = split(",K,M,G,T,E", suffixes, /,/)
		for (suffix = 1; suffix <= n; suffix++) {
			if (int(value) < 1024) break
			value /= 1024
		}
		if (v ~ /\./) sub(/\.?0+$/, "", v)
		value = sprintf("%'"'"'.2f%sB/s", value, suffixes[suffix])
		return value
	}

	function _asort(src, dest,        k, nitems, i, val)
	{
		k = nitems = 0
		for (i in src) dest[++nitems] = src[i]
		for (i = 1; i <= nitems; k = i++) {
			val = dest[i]
			while ((k > 0) && (dest[k] > val)) {
				dest[k+1] = dest[k]; k--
			}
			dest[k+1] = val
		}
		return nitems
	}

	function json_add(json, key, format, value)
	{
		return json (length(json) < 2 ? "" : ",") \
			sprintf("\"%s\":" format, key, value)
	}

	function json_add_str(json, key, value)
	{
		return json_add(json, key, "\"%s\"", value)
	}

	function json_add_uint(json, key, value)
	{
		return json_add(json, key, "%u", value)
	}

	function json_add_prec(json, key, precision, value,        x)
	{
		x = sprintf("%.*f", precision, value)
		if (x ~ /\./) sub(/\.?0+$/, "", x)
		return json_add(json, key, "%s", x)
	}

	function json_add_float(json, key, value)
	{
		return json_add_prec(json, key, 12, value)
	}

	function sample_check()
	{
		if (nsamples > 0 && --samples_left < 1) {
			system(sprintf("kill %d > /dev/null 2>&1", bpid))
			exit
		}
	}

	function process_view(curview,
		cred_read, read_bar, read_bar_pct, read_rate, read_total,
		cred_write, write_bar, write_bar_pct, write_rate, write_total,
		i, n, r, v, _keys_sorted, table_rows, cred)
	{
		read_total = map_view_read[curview]
		read_rate = read_total / interval
		write_total = map_view_write[curview]
		write_rate = write_total / interval

		if (output_json) {
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out,
				"ident", "total_" curview)
			json_out = json_add_uint(json_out,
				"total_bytes", read_total + write_total)
			json_out = json_add_float(json_out,
				"total_rate", read_rate + write_rate)
			json_out = json_add_uint(json_out,
				"read_bytes", read_total)
			json_out = json_add_float(json_out,
				"read_rate", read_rate)
			json_out = json_add_uint(json_out,
				"write_bytes", write_total)
			json_out = json_add_float(json_out,
				"write_rate", write_rate)
			buffer_add("{" json_out "}\n")
		} else {
			read_bar = ""
			write_bar = ""
			buffer_add(sprintf(fmt, "total",
				humanize(write_rate + read_rate),
				humanize(write_rate), bar_size, write_bar,
				bar_size, read_bar, humanize(read_rate)))
		}

		#
		# Decorate combined read/write values
		#
		load_keys(curview)
		for (cred in _keys) {
			v = int(map_key_read[curview, cred]) + \
				int(map_key_write[curview, cred])
			_keys[cred] = sprintf("%99d %s", v, cred)
		}

		#
		# Print subtotals
		#
		r = 1
		n = _asort(_keys, _keys_sorted)
		table_rows = output_json ? n : rows - 4
		for (i = n; i >= 1 && r++ <= table_rows; i--) {
			cred = _keys_sorted[i]
			sub(/^ *[^ ]+ +/, "", cred) # Undecorate

			cred_read = map_key_read[curview, cred]
			cred_write = map_key_write[curview, cred]

			read_rate = cred_read / interval
			if (read_total > 0)
				read_bar_pct = cred_read / read_total
			else
				read_bar_pct = 0
			read_bar_size = bar_size * read_bar_pct
			read_bar = sprintf("%*s", read_bar_size, "")
			gsub(/ /, "=", read_bar)
			sub(/.$/, ">", read_bar)

			write_rate = cred_write / interval
			if (write_total > 0)
				write_bar_pct = cred_write / write_total
			else
				write_bar_pct = 0
			write_bar_size = bar_size * write_bar_pct
			write_bar = sprintf("%*s", write_bar_size, "")
			gsub(/ /, "=", write_bar)
			sub(/^./, "<", write_bar)

			if (!no_names) {
				if (curview == "group") {
					if (cred in gid2name)
						cred = gid2name[cred]
				} else if (curview == "user") {
					if (cred in uid2name)
						cred = uid2name[cred]
				}
				if (!output_json && length(cred) > vsz) {
					cred = "..." substr(cred,
						length(cred) - vsz + 4)
				}
			}

			if (output_json) {
				json_out = ""
				json_out = json_add_uint(json_out, "time", tm)
				json_out = json_add_str(json_out,
					"ident", curview)
				json_out = json_add_str(json_out, curview, cred)
				json_out = json_add_uint(json_out,
					"total_bytes", cred_read + cred_write)
				json_out = json_add_float(json_out,
					"total_rate", read_rate + write_rate)
				json_out = json_add_uint(json_out,
					"read_bytes", cred_read)
				json_out = json_add_float(json_out,
					"read_rate", read_rate)
				json_out = json_add_uint(json_out,
					"write_bytes", cred_write)
				json_out = json_add_float(json_out,
					"write_rate", write_rate)
				buffer_add("{" json_out "}\n")
			} else {
				buffer_add(sprintf(fmt, cred,
					humanize(write_rate + read_rate),
					humanize(write_rate), bar_size,
					write_bar, bar_size, read_bar,
					humanize(read_rate)))
			}
		}
		if (i > 0) buffer_add(sprintf("(%d more) ... ", i))
	}

	######################################## MAIN

	raw_view {
		print

		# Exit if no more samples desired
		if (/^---$/) sample_check()

		next
	}

	/^===$/ {
		read_total = write_total = 0
		clear_buffer()
		buffer_add_header()
		next
	}

	sub(/^info\|/, "") {
		if (!output_json) print
		next
	}

	/^@/ { parse_map() }

	/^---$/ {
		tm = systime()

		#
		# Process each requested view
		#
		for (v = 1; v <= nviews; v++)
			process_view(view_list[v])

		#
		# Dump information
		#
		print_buffer()
		clear_data()
		sample_check() # Exit if no more samples desired
	}

	############################################################
	# END
	############################################################
' # END-QUOTE
/* -*- mode: dtrace-script; tab-width: 4 -*- ;; Emacs
 * vi: set ft=dtrace noet ts=4 sw=4 :: Vi/ViM
 */
////////////////////////////////////////////////// INCLUDES

#include <linux/sunrpc/svc.h>

////////////////////////////////////////////////// BEGIN

BEGIN {
	printf("===\n"); // Clear screen and draw header
	printf("info|Sampling data for ${INTERVAL}s (\`-i sec')...\n");
}

////////////////////////////////////////////////// READ PROBES

kprobe:nfsd_read
{
	@nfsd_read_rqstp[tid] = (struct svc_rqst *)arg0;
	@nfsd_read_countp[tid] = arg5;
}

${VIEW_FILE:+"
kprobe:nfsd_init_raparms
/@nfsd_read_rqstp[tid] != 0/
{
	@nfsd_read_filep[tid] = (struct file *)arg0;
}
"}

kretprobe:nfsd_read
/@nfsd_read_rqstp[tid] != 0 && @nfsd_read_countp[tid] != 0/
{
	\$rqstp = @nfsd_read_rqstp[tid];
	\$uid = \$rqstp->rq_cred.cr_uid.val;
	\$gid = \$rqstp->rq_cred.cr_gid.val;
	\$countp = @nfsd_read_countp[tid];
	\$bytes = *\$countp;

	delete(@nfsd_read_countp[tid]);
	delete(@nfsd_read_rqstp[tid]);

	\$filtered = 0;

${FILTER_GROUP:+"
	if (\$gid != $FILTER_GROUP) { \$filtered = 1; }
"}
${FILTER_USER:+"
	if (\$uid != $FILTER_USER) { \$filtered = 1; }
"}

	if (\$filtered == 0)
	{
${VIEW_CLIENT:+"
		if (\$rqstp->rq_addr.ss_family == AF_INET) {
			\$data = (int64 *)\$rqstp->rq_addr.__data;
			\$num = (int64)*\$data;
			\$ip4 = \$num >> 16 & 0xFFFFFFFF;
			\$client = ntop(AF_INET, \$ip4);

			@rd_client[\$client] = sum(\$bytes);
		}
"}

${VIEW_FILE:+"
		\$file = @nfsd_read_filep[tid];
		\$de = \$file->f_dentry;
		\$n1 = \$de->d_name.name;
		\$de = \$de->d_parent;
		\$n2 = \$de->d_name.name;

		delete(@nfsd_read_filep[tid]);

		@rd_file[str(\$n2), str(\$n1)] = sum(\$bytes);
"}

${VIEW_GROUP:+"
		@rd_group[\$gid] = sum(\$bytes);
"}

${VIEW_SERVER:+"
		if (\$rqstp->rq_daddr.ss_family == AF_INET) {
			\$data = (int64 *)\$rqstp->rq_daddr.__data;
			\$num = (int64)*\$data;
			\$ip4 = \$num >> 16 & 0xFFFFFFFF;
			\$server = ntop(AF_INET, \$ip4);

			@rd_server[\$server] = sum(\$bytes);
		}
"}

${VIEW_USER:+"
		@rd_user[\$uid] = sum(\$bytes);
"}
	}
}

////////////////////////////////////////////////// WRITE PROBES

kprobe:nfsd_write
{
	@nfsd_write_rqstp[tid] = (struct svc_rqst *)arg0;
	@nfsd_write_countp[tid] = arg5;
}

${VIEW_FILE:+"
kprobe:nfsd_vfs_write
/@nfsd_write_rqstp[tid] != 0/
{
	@nfsd_write_filep[tid] = (struct file *)arg2;
}
"}

kretprobe:nfsd_write
/@nfsd_write_rqstp[tid] != 0 && @nfsd_write_countp[tid] != 0/
{
	\$rqstp = @nfsd_write_rqstp[tid];
	\$uid = \$rqstp->rq_cred.cr_uid.val;
	\$gid = \$rqstp->rq_cred.cr_gid.val;
	\$countp = @nfsd_write_countp[tid];
	\$bytes = *\$countp;

	delete(@nfsd_write_countp[tid]);
	delete(@nfsd_write_rqstp[tid]);

	\$filtered = 0;

${FILTER_GROUP:+"
	if (\$gid != $FILTER_GROUP) { \$filtered = 1; }
"}
${FILTER_USER:+"
	if (\$uid != $FILTER_USER) { \$filtered = 1; }
"}

	if (\$filtered == 0)
	{
${VIEW_CLIENT:+"
		if (\$rqstp->rq_addr.ss_family == AF_INET) {
			\$data = (int64 *)\$rqstp->rq_addr.__data;
			\$num = (int64)*\$data;
			\$ip4 = \$num >> 16 & 0xFFFFFFFF;
			\$client = ntop(AF_INET, \$ip4);

			@wr_client[\$client] = sum(\$bytes);
		}
"}

${VIEW_FILE:+"
		\$file = @nfsd_write_filep[tid];
		\$de = \$file->f_dentry;
		\$n1 = \$de->d_name.name;
		\$de = \$de->d_parent;
		\$n2 = \$de->d_name.name;

		delete(@nfsd_write_filep[tid]);

		@wr_file[str(\$n2), str(\$n1)] = sum(\$bytes);
"}

${VIEW_GROUP:+"
		@wr_group[\$gid] = sum(\$bytes);
"}

${VIEW_SERVER:+"
		if (\$rqstp->rq_daddr.ss_family == AF_INET) {
			\$data = (int64 *)\$rqstp->rq_daddr.__data;
			\$num = (int64)*\$data;
			\$ip4 = \$num >> 16 & 0xFFFFFFFF;
			\$server = ntop(AF_INET, \$ip4);

			@wr_server[\$server] = sum(\$bytes);
		}
"}

${VIEW_USER:+"
		@wr_user[\$uid] = sum(\$bytes);
"}
	}
}

////////////////////////////////////////////////// INTERVAL PROBE

$INTERVAL_PROBE
{
	printf("===\n");

${VIEW_CLIENT:+
	print(@rd_client);
	print(@wr_client);
	clear(@rd_client);
	clear(@wr_client);
}
${VIEW_FILE:+
	print(@rd_file);
	print(@wr_file);
	clear(@rd_file);
	clear(@wr_file);
}
${VIEW_GROUP:+
	print(@rd_group);
	print(@wr_group);
	clear(@rd_group);
	clear(@wr_group);
}
${VIEW_SERVER:+
	print(@rd_server);
	print(@wr_server);
	clear(@rd_server);
	clear(@wr_server);
}
${VIEW_USER:+
	print(@rd_user);
	print(@wr_user);
	clear(@rd_user);
	clear(@wr_user);
}

	printf("---\n");
}

////////////////////////////////////////////////// END

END
{
${VIEW_CLIENT:+
	clear(@rd_client);
	clear(@wr_client);
}
${VIEW_FILE:+
	clear(@nfsd_read_filep);
	clear(@nfsd_write_filep);
	clear(@rd_file);
	clear(@wr_file);
}
${VIEW_GROUP:+
	clear(@rd_group);
	clear(@wr_group);
}
${VIEW_USER:+
	clear(@rd_user);
	clear(@wr_user);
}
${VIEW_SERVER:+
	clear(@rd_server);
	clear(@wr_server);
}

	clear(@nfsd_read_countp);
	clear(@nfsd_read_rqstp);
	clear(@nfsd_write_countp);
	clear(@nfsd_write_rqstp);
}

//////////////////////////////////////////////////////////////////////
// END
//////////////////////////////////////////////////////////////////////
EOF

exit $SUCCESS

################################################################################
# END
################################################################################
