#!/bin/sh
# vi: set ft=sh noet ts=8 sw=8 :: Vi/ViM
############################################################ IDENT(1)
#
# $Title: Script to generate top-like statistics for nfsd I/O $
# $Copyright: 2020 Devin Teske. All rights reserved. $
# $FrauBSD: nfsdtop/nfsdtop.linux 2020-07-06 18:05:10 -0700 freebsdfrau $
#
############################################################ INFORMATION
#
# In nfsdtop, a ``view'' is the user's choice between -c, -g, -s, or -u.
# For example, `-u' asks nfsdtop to display the ``user view'' where statistics
# displayed are on a per-user basis.
#
# The ``mode'' is the user's choice between viewing data input/output (this is
# the default) and metadata operations (-m). When presenting data in JSON (-j)
# use -M to get both data and metadata options.
#
# The code is broken down into:
# 	- Mode selection (user choice)
# 	- View selection (user choice)
# 	- Filter selection (user choice)
# 	- bpftrace execution
# 	- awk to process bpftrace output
#
# Code navigating Search Terms/ST:
# 	BPFTRACE	Start of bpftrace
# 	FILTERS		Data filters
# 	JSONDATA	JSON data generation
# 	OPS		Data operations (read vs write)
# 	POST		bpftrace post-processor (awk)
# 	PRE		Start of pre-processor (sh)
# 	SORTING		Sort routines
# 	TRACEDATA	bpftrace data generation and processing
# 	VIEWDATA	View data generation
# 	VIEWS		View processing
#
############################################################ DEFAULTS

DEFAULT_INTERVAL=2.0 # seconds

#
# Sorting choices (case-insensitive):
# 	total (in any mode; default sort column)
# 	read write in out (without `-m')
# 	good fail (with `-m')
#
DEFAULT_SORT=total

#
# User/Group map files
#
DEFAULT_PASSWD_MAP=.nfsd.passwd
DEFAULT_GROUP_MAP=.nfsd.group

#
# Network IP map file
#
DEFAULT_IP_MAP=.nfsd.hosts

############################################################ GLOBALS

VERSION='$Version: 7.0.1 $'

pgm="${0##*/}" # Program basename

#
# Global exit status
#
SUCCESS=0
FAILURE=1

#
# Command-line options
#
COLOR=1					# -a
DEBUG=					# -d
DEBUGGER=				# -D
FILTER_CLIENT=				# -C ip
FILTER_FILE=				# -F regex
FILTER_GROUP=				# -G group
FILTER_SERVER=				# -S ip
FILTER_USER=				# -U user
GROUP_MAP="$DEFAULT_GROUP_MAP"		# -P file
INTERVAL=$DEFAULT_INTERVAL		# -i sec
IP_MAP="$DEFAULT_IP_MAP"		# -I file
MODE=data				# vs `meta' (-m) or `both' (-M)
NO_NAMES=				# -n
NSAMPLES=				# -N num
OUTPUT_JSON=				# -j
PASSWD_MAP="$DEFAULT_PASSWD_MAP"	# -p file
QUIET=					# -q
RAW_VIEW=				# -r
REDACT=${NFSDTOP_REDACT:+1}		# -R
SHOW_BASIC=				# -b
SORT=$DEFAULT_SORT			# -k col
VIEW_CLIENT=				# -c
VIEW_FILE=				# -f
VIEW_GROUP=				# -g
VIEW_SERVER=				# -s
VIEW_USER=				# -u (default)
WIDE_VIEW=				# -w

#
# Miscellaneous
#
CB='}'
CONS=1
[ -t 1 ] || CONS= COLOR= # stdout is not a tty
DQ='"'
_FILTER_CLIENT=
_FILTER_GROUP=
_FILTER_SERVER=
_FILTER_USER=
INTERVAL_PROBE= # Calculated
INTERVAL_SECONDS= # Raw value for awk
MODE_DATA=
MODE_META=
VIEW=

############################################################ FUNCTIONS

die()
{
	local fmt="$1"
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@" >&2
	fi
	exit $FAILURE
}

usage()
{
	local fmt="$1"
	local optfmt="\t%-11s %s\n"

	exec >&2
	if [ "$fmt" ]; then
		shift 1 # fmt
		printf "%s: $fmt\n" "$pgm" "$@"
	fi

	printf "Usage: %s [OPTIONS]\n" "$pgm"
	printf "Options:\n"
	printf "$optfmt" "-a" "Always enable color."
	printf "$optfmt" "-b" "Show basic counts instead of rates."
	printf "$optfmt" "-C ip" "Client filter (IPv4 only)."
	printf "$optfmt" "-c" "View read/write activity by client."
	printf "$optfmt" "-D" "Enable debugger."
	printf "$optfmt" "-d" "Debug. Print bpftrace script and exit."
	printf "$optfmt" "-F regex" "File filter. Implies \`-f'."
	printf "$optfmt" "-f" \
		"View read/write activity by file. Implies \`-w'."
	printf "$optfmt" "-G group" "Group filter (name or id)."
	printf "$optfmt" "-g" "View read/write activity by group."
	printf "$optfmt" "-h" "Print usage statement and exit."
	printf "$optfmt" "-I file" "IP map file. Default \`$DEFAULT_IP_MAP'."
	printf "$optfmt" "-i sec" \
		"Set interval seconds. Default \`$DEFAULT_INTERVAL'."
	printf "$optfmt" "-J" "Output most JSON data. Same as \`-cgjMsu'."
	printf "$optfmt" "-j" "Output JSON formatted data."
	printf "$optfmt" "-k col" "Sort column (default \`$DEFAULT_SORT')."
	printf "$optfmt" "-M" "Show metadata statistics (requires \`-j')."
	printf "$optfmt" "-m" "Only show metadata statistics."
	printf "$optfmt" "-N num" "Perform num samples and exit."
	printf "$optfmt" "-n" "Do not attempt to map uid/gid/ip to names."
	printf "$optfmt" "-o" "Force non-console output."
	printf "$optfmt" "-P file" \
		"Group map file. Default \`$DEFAULT_GROUP_MAP'."
	printf "$optfmt" "-p file" \
		"User map file. Default \`$DEFAULT_PASSWD_MAP'."
	printf "$optfmt" "-q" "Quiet. Hide informational messages."
	printf "$optfmt" "-R" "Redact potentially sensitive information."
	printf "$optfmt" "-r" "Raw view. Do not format output of bpftrace."
	printf "$optfmt" "-S ip" "Server filtter (IPv4 only)."
	printf "$optfmt" "-s" "View read/write activity by server."
	printf "$optfmt" "-U user" "User filter (name or id)."
	printf "$optfmt" "-u" "View read/write activity by user (default)."
	printf "$optfmt" "-v" "Print version and exit."
	printf "$optfmt" "-w" "Wide view. Maximize width of first column."

	die
}

run_bpftrace()
{
	if [ "$DEBUG" ]; then
		cat
		return
	fi

	bpftrace -B none /dev/stdin "$@"
}

isint()
{
	local arg="${1#-}"
	[ "${arg:-x}" = "${arg%[!0-9]*}" ]
}

isip()
{
        local IFS=. noctets=0 octet
        for octet in $1; do
                [ "$octet" ] || return 2
                isint "$octet" || return 3
                [ $octet -ge 0 ] || return 4
                [ $octet -gt 255 ] && return 5
                noctets=$(( $noctets + 1 ))
        done
        [ $noctets -eq 4 ]
}

checkip()
{
	isip "$1"
	case $? in
	1) die "-C argument \`%s' too many dots" "$1" ;;
	2) die "-C argument \`%s' missing octet" "$1" ;;
	3) die "-C argument \`%s' bad octet" "$1" ;;
	4) die "-C argument \`%s' negative octet" "$1" ;;
	5) die "-C argument \`%s' too big octet" "$1" ;;
	esac
}

atoi()
{
	local __addr="$1" __var_to_set="$2" __num=0
	if isip "$__addr"; then
		local IFS=.
		set -- $__addr
		__num=$(( ($1 << 24) + ($2 << 16) + ($3 << 8) + $4 ))
	fi
	eval $__var_to_set=$__num
}

#
# ST: CALLS
#

send_user()
{
	local type="$1"
	shift 1 # type
	printf "%s|%s\n" "$type" "$*"
}

info() { send_user info "$*"; }

resize()
{
	local size
	if [ -e /dev/tty ]; then
		size=$( { stty size < /dev/tty; } 2> /dev/null )
	else
		size=$( stty size 2> /dev/null )
	fi
	send_user resize "${size:-24 80}"
}

############################################################ MAIN

#
# Process command-line options
#
while getopts abC:cDdF:fG:ghi:Jjk:MmN:noP:p:qRrS:sU:uvw flag; do
	case "$flag" in
	a) COLOR=1 ;;
	b) SHOW_BASIC=1 ;;
	C) FILTER_CLIENT="$OPTARG" ;;
	c) VIEW=CLIENT VIEW_CLIENT=1 ;;
	D) DEBUGGER=1 RAW_VIEW=1 ;;
	d) DEBUG=1 RAW_VIEW=1 ;;
	F) VIEW=FILE VIEW_FILE=1 WIDE_VIEW=1 FILTER_FILE="$OPTARG" ;;
	f) VIEW=FILE VIEW_FILE=1 WIDE_VIEW=1 ;;
	G) FILTER_GROUP="$OPTARG" ;;
	g) VIEW=GROUP VIEW_GROUP=1 ;;
	i) INTERVAL="$OPTARG" ;;
	J) VIEW=JSON OUTPUT_JSON=1 MODE=both \
		VIEW_CLIENT=1 VIEW_GROUP=1 VIEW_SERVER=1 VIEW_USER=1 ;;
	j) OUTPUT_JSON=1 ;;
	k) SORT="$OPTARG" ;;
	M) MODE=both ;;
	m) MODE=meta ;;
	N) [ "$OPTARG" ] || usage "-N option requires an argument" # NOTREACHED
		NSAMPLES="$OPTARG" ;;
	n) NO_NAMES=1 ;;
	o) CONS= COLOR= ;;
	P) GROUP_MAP="$OPTARG" ;;
	p) PASSWD_MAP="$OPTARG" ;;
	q) QUIET=1 ;;
	R) REDACT=1 ;;
	r) RAW_VIEW=1 ;;
	S) FILTER_SERVER="$OPTARG" ;;
	s) VIEW=SERVER VIEW_SERVER=1 ;;
	U) FILTER_USER="$OPTARG" ;;
	u) VIEW=USER VIEW_USER=1 ;;
	v) VERSION="${VERSION#*: }"
		echo "${VERSION% $}"
		exit $SUCCESS ;;
	w) WIDE_VIEW=1 ;;
	*) usage # NOTREACHED
	esac
done
shift $(( $OPTIND - 1 ))

#
# Process command-line arguments
#
[ $# -eq 0 ] || usage "Too many arguments" # NOTREACHED

#
# Prevent non-functional option combinations
#
if [ "$SHOW_BASIC" ]; then
	[ "$VIEW" != "JSON" ] || die "-b cannot be combined with -J"
	[ ! "$OUTPUT_JSON" ] || die "-b cannot be combined with -j"
fi
case "$MODE" in
both) [ "$OUTPUT_JSON" ] || die "-M requires -j or -J" ;;
esac

#
# Silently ignore previous view options unless JSON output
#
[ "$VIEW" ] || VIEW=USER VIEW_USER=1
if [ ! "$OUTPUT_JSON" ]; then
	case "$VIEW" in # ST: VIEWS
	CLIENT) VIEW_FILE= VIEW_GROUP= VIEW_SERVER= VIEW_USER= ;;
	FILE) VIEW_CLIENT= VIEW_GROUP= VIEW_SERVER= VIEW_USER= ;;
	GROUP) VIEW_CLIENT= VIEW_FILE= VIEW_SERVER= VIEW_USER= ;;
	SERVER) VIEW_CLIENT= VIEW_FILE= VIEW_GROUP= VIEW_USER= ;;
	USER) VIEW_CLIENT= VIEW_FILE= VIEW_GROUP= VIEW_SERVER= ;;
	esac
fi

#
# Validate `-i sec' option
#
case "$INTERVAL" in
"") usage "missing -i argument" ;; # NOTREACHED
0) die "-i sec must be non-zero" ;;
*[!0-9.]*|*.*.*|.) die "-i sec must be a number" ;;
*.*)
	INTERVAL_SECONDS=$INTERVAL
	ms=$( echo "$INTERVAL * 1000" | bc )
	ms="${ms%%.*}"

	#
	# If, after multiplying by 1000 to convert sec to msec,
	# the leading [non-decimal] digit is either missing or zero,
	# the input was too small to produce timing of at least 1 msec
	#
	case "$ms" in
	""|0) die "-i sec must be at least 0.001" ;;
	esac

	INTERVAL_PROBE=interval:ms:$ms
	;;
*)
	INTERVAL_SECONDS=$INTERVAL
	INTERVAL_PROBE=interval:s:$INTERVAL_SECONDS
esac

#
# Validate `-k col' option
# ST: SORTING
#
if [ "$MODE" = data ]; then
	case "$SORT" in
	"") usage "missing -k argument" ;; # NOTREACHED
	[Tt][Oo][Tt][Aa][Ll]) SORT=total ;; # TOTAL
	[Rr][Ee][Aa][Dd]|[Ii][Nn]) SORT=read ;; # READ(IN)
	[Ww][Rr][Ii][Tt][Ee]|[Oo][Uu][Tt]) SORT=write ;; # WRITE(OUT)
	*) die "-k col must be one of: total read write in out"
	esac
elif [ "$MODE" = meta ]; then
	case "$SORT" in
	"") usage "missing -k argument" ;; # NOTREACHED
	[Tt][Oo][Tt][Aa][Ll]) SORT=total ;; # TOTAL
	[Gg][Oo][Oo][Dd]) SORT=good ;; # STAT(GOOD)
	[Ff][Aa][Ii][Ll]) SORT=fail ;; # STAT(FAIL)
	*) die "-k col must be one of: total good fail"
	esac
elif [ "$MODE" = both ]; then
	case "$SORT" in
	"") usage "missing -k argument" ;; # NOTREACHED
	[Tt][Oo][Tt][Aa][Ll]) SORT=total ;; # TOTAL
	[Rr][Ee][Aa][Dd]|[Ii][Nn]) SORT=read ;; # READ(IN)
	[Ww][Rr][Ii][Tt][Ee]|[Oo][Uu][Tt]) SORT=write ;; # WRITE(OUT)
	[Gg][Oo][Oo][Dd]) SORT=good ;; # STAT(GOOD)
	[Ff][Aa][Ii][Ll]) SORT=fail ;; # STAT(FAIL)
	*) die "-k col must be one of: total read write in out good fail"
	esac
fi

#
# Process `-m' and `-M' options
#
case "$MODE" in
both) MODE_DATA=1 MODE_META=1 ;;
data) MODE_DATA=1 MODE_META= ;;
meta) MODE_META=1 MODE_DATA= ;;
esac

#
# Validate `-N num' option
#
case "$NSAMPLES" in
0) die "-N num must be non-zero" ;;
*[!0-9]*) die "-N num must be a positive integer" ;;
esac

#
# Process `-G group'/`-U user' option
#
case "$FILTER_GROUP" in
"") : leave-empty ;;
*[!0-9]*) # Translate from name to GID
	_FILTER_GROUP=$( awk \
		-v sq="'" \
		-v group_map="$GROUP_MAP" \
		-v name="$FILTER_GROUP" \
	'BEGIN {
		delete name2gid
		while (getline < group_map > 0) {
			n = split($0, fields, /:/)
			name2gid[fields[1]] = fields[3]
		}
		close(group_map)
		if (name in name2gid) {
			print name2gid[name]
			exit 0
		}
		gsub(sq, "&\\\\&&", name)
		cmd = sprintf("getent group %s%s%s", sq, name, sq)
		cmd | getline group
		close(cmd)
		if (split(group, fields, /:/) >= 3) {
			print fields[3]
			exit 0
		}
		exit 1
	}' 2> /dev/null ) || die "Unknown group %s" "$FILTER_GROUP"
	FILTER_GROUP="$_FILTER_GROUP"
	;;
esac
case "$FILTER_USER" in
"") : leave-empty ;;
*[!0-9]*) # Translate from name to UID
	_FILTER_USER=$( awk \
		-v sq="'" \
		-v user_map="$PASSWD_MAP" \
		-v name="$FILTER_USER" \
	'BEGIN {
		delete uid2name
		while (getline < user_map > 0) {
			n = split($0, fields, /:/)
			name2uid[fields[1]] = fields[3]
		}
		close(user_map)
		if (name in name2uid) {
			print name2uid[name]
			exit 0
		}
		gsub(sq, "&\\\\&&", name)
		cmd = sprintf("getent passwd %s%s%s", sq, name, sq)
		cmd | getline passwd
		close(cmd)
		if (split(passwd, fields, /:/) >= 3) {
			print fields[3]
			exit 0
		}
		exit 1
	}' ) || die "Unknown user %s" "$FILTER_USER"
	FILTER_USER="$_FILTER_USER"
	;;
esac

#
# Process `-C ip'/`-S ip' option
#
case "$FILTER_CLIENT" in
"") : ok ;;
*[a-zA-Z]*)
	_FILTER_CLIENT=$( awk \
		-v sq="'" \
		-v ip_map="$IP_MAP" \
		-v host="$FILTER_CLIENT" \
	'BEGIN {
		delete host2ip
		while (getline < ip_map > 0) {
			if (/^[[:space:]]*(#|$)/) continue
			n = split($0, fields, /[[:space:]]+/)
			host2ip[fields[2]] = fields[1]
		}
		close(ip_map)
		if (host in host2ip) {
			print host2ip[host]
			exit 0
		} else if (host !~ /\.$/ && (host ".") in host2ip) {
			print host2ip[host "."]
			exit 0
		}
		gsub(sq, "&\\\\&&", host)
		cmd = sprintf("host -t A %s%s%s", sq, host, sq)
		cmd | getline
		close(cmd)
		if ($NF !~ /NXDOMAIN/) {
			print $NF
			exit 0
		}
		exit 1
	}' 2> /dev/null ) || die "Unknown host %s" "$FILTER_CLIENT"
	FILTER_CLIENT="$_FILTER_CLIENT"
	checkip "$FILTER_CLIENT" # NOTREACHED if non-ip
	atoi $FILTER_CLIENT FILTER_CLIENT
	;;
*)
	checkip "$FILTER_CLIENT" # NOTREACHED if non-ip
	atoi $FILTER_CLIENT FILTER_CLIENT
	;;
esac
case "$FILTER_SERVER" in
"") : leave-empty ;;
*[a-zA-Z]*) # Translate from name to IP
	_FILTER_SERVER=$( awk \
		-v sq="'" \
		-v ip_map="$IP_MAP" \
		-v host="$FILTER_SERVER" \
	'BEGIN {
		delete host2ip
		while (getline < ip_map > 0) {
			if (/^[[:space:]]*(#|$)/) continue
			n = split($0, fields, /[[:space:]]+/)
			host2ip[fields[2]] = fields[1]
		}
		close(ip_map)
		if (host in host2ip) {
			print host2ip[host]
			exit 0
		} else if (host !~ /\.$/ && (host ".") in host2ip) {
			print host2ip[host "."]
			exit 0
		}
		gsub(sq, "&\\\\&&", host)
		cmd = sprintf("host -t A %s%s%s", sq, host, sq)
		cmd | getline
		close(cmd)
		if ($NF !~ /NXDOMAIN/) {
			print $NF
			exit 0
		}
		exit 1
	}' 2> /dev/null ) || die "Unknown host %s" "$FILTER_SERVER"
	FILTER_SERVER="$_FILTER_SERVER"
	checkip "$FILTER_SERVER" # NOTREACHED if non-ip
	atoi $FILTER_SERVER FILTER_SERVER
	;;
*)
	checkip "$FILTER_SERVER" # NOTREACHED if non-ip
	atoi $FILTER_SERVER FILTER_SERVER
	;;
esac

#
# Get terminal size
#
size=$( resize )
size="${size#*|}"
if [ "$size" ]; then
	cols="${size#*[$IFS]}"
	rows="${size%%[$IFS]*}"
fi
case "$rows$cols" in
""|*[!0-9]*)
	cols=80
	rows=24
	;;
esac

#
# Run script
# ST: PRE
#
{
	trap resize WINCH # ST: SIGWINCH

	#
	# Start background bpftrace
	# NB: M-x package-install [RET] dtrace-script-mode [RET]
	# ST: BPFTRACE
	#
	run_bpftrace <<EOF &
	${DEBUG:+#!/usr/bin/bpftrace}
	/* -*- mode: dtrace-script; tab-width: 4 -*- ;; Emacs
	 * vi: set ft=dtrace noet ts=4 sw=4 :: Vi/ViM
	 */
	////////////////////////////////////////////////// INCLUDES

	#include <linux/sunrpc/svc.h>

	////////////////////////////////////////////////// BEGIN

	BEGIN
	{
		time("time|%s\n");
		printf("init|"); // Initialize post-processor
		printf("===\n"); // Clear screen and draw header
		printf("info|Sampling data for ${INTERVAL}s (\`-i sec')...\n");
	}

	////////////////////////////////////////////////// STAT PROBE

	/*
	 * stat(2, 3) probes
	 */

${MODE_META:+
	kprobe:nfsd3_proc_getattr
	{
		\$rqstp = (struct svc_rqst *)arg0;
		@nfsd_getattr_rqstp[tid] = \$rqstp;
		\$data = (int64 *)\$rqstp->rq_addr.__data;
		\$num = (int64)*\$data;
		@nfsd_getattr_client[tid] = \$num >> 16 & 0xFFFFFFFF;
		\$data = (int64 *)\$rqstp->rq_daddr.__data;
		\$num = (int64)*\$data;
		@nfsd_getattr_server[tid] = \$num >> 16 & 0xFFFFFFFF;
	$CB

${VIEW_FILE:+
	kprobe:nfsd_init_raparms
	/@nfsd_getattr_rqstp[tid] != 0/
	{
		@nfsd_getattr_filep[tid] = (struct file *)arg0;
	$CB
}

	kretprobe:nfsd3_proc_getattr
	/@nfsd_getattr_rqstp[tid] != 0/
	{
		\$rqstp = @nfsd_getattr_rqstp[tid];
		\$uid = \$rqstp->rq_cred.cr_uid.val;
		\$gid = \$rqstp->rq_cred.cr_gid.val;
		\$retval = retval;

		\$client_ip4 = @nfsd_getattr_client[tid];
		\$client_ip4num = (uint32)(\$client_ip4 >> 24 |
			(\$client_ip4 >> 16 & 0xFF) << 8 |
			(\$client_ip4 >> 8 & 0xFF) << 16 |
			(\$client_ip4 & 0xFF) << 24);

		\$server_ip4 = @nfsd_getattr_server[tid];
		\$server_ip4num = (uint32)(\$server_ip4 >> 24 |
			(\$server_ip4 >> 16 & 0xFF) << 8 |
			(\$server_ip4 >> 8 & 0xFF) << 16 |
			(\$server_ip4 & 0xFF) << 24);

		delete(@nfsd_getattr_client[tid]);
		delete(@nfsd_getattr_rqstp[tid]);
		delete(@nfsd_getattr_server[tid]);

${VIEW_FILE:+
		\$file = @nfsd_getattr_filep[tid];
		\$de = \$file->f_dentry;
		\$n1 = \$de->d_name.name;
		\$de = \$de->d_parent;
		\$n2 = \$de->d_name.name;

		delete(@nfsd_getattr_filep[tid]);
}

		\$filtered = 0;

		// ST: FILTERS
${FILTER_CLIENT:+
		if (\$client_ip4num != $FILTER_CLIENT) { \$filtered = 1; $CB
}
${FILTER_GROUP:+
		if (\$gid != $FILTER_GROUP) { \$filtered = 1; $CB
}
${FILTER_SERVER:+
		if (\$server_ip4num != $FILTER_SERVER) { \$filtered = 1; $CB
}
${FILTER_USER:+
		if (\$uid != $FILTER_USER) { \$filtered = 1; $CB
}

		if (\$filtered == 0)
		{
			if (\$retval == 0) {
				// ST: VIEWS TRACEDATA
${VIEW_CLIENT:+
				@stat_good_client[ntop(AF_INET, \$client_ip4)] = count();
}
${VIEW_FILE:+
				@stat_good_file[str(\$n2), str(\$n1)] = count();
}
${VIEW_GROUP:+
			@stat_good_group[\$gid] = count();
}
${VIEW_SERVER:+
			@stat_good_server[ntop(AF_INET, \$server_ip4)] = count();
}
${VIEW_USER:+
			@stat_good_user[\$uid] = count();
}
			$CB
			else
			{
				// ST: VIEWS TRACEDATA
${VIEW_CLIENT:+
				@stat_fail_client[ntop(AF_INET, \$client_ip4)] = count();
}
${VIEW_FILE:+
				@stat_fail_file[str(\$n2), str(\$n1)] = count();
}
${VIEW_GROUP:+
			@stat_fail_group[\$gid] = count();
}
${VIEW_SERVER:+
			@stat_fail_server[ntop(AF_INET, \$server_ip4)] = count();
}
${VIEW_USER:+
			@stat_fail_user[\$uid] = count();
}
			$CB
		$CB
	$CB
}

	////////////////////////////////////////////////// READ PROBES

	/*
	 * read(2) probes
	 */

${MODE_DATA:+
	kprobe:nfsd_read
	{
		\$rqstp = (struct svc_rqst *)arg0;
		@nfsd_read_rqstp[tid] = \$rqstp;
		@nfsd_read_countp[tid] = arg5;
		\$data = (int64 *)\$rqstp->rq_addr.__data;
		\$num = (int64)*\$data;
		@nfsd_read_client[tid] = \$num >> 16 & 0xFFFFFFFF;
		\$data = (int64 *)\$rqstp->rq_daddr.__data;
		\$num = (int64)*\$data;
		@nfsd_read_server[tid] = \$num >> 16 & 0xFFFFFFFF;
	$CB

${VIEW_FILE:+
	kprobe:nfsd_init_raparms
	/@nfsd_read_rqstp[tid] != 0/
	{
		@nfsd_read_filep[tid] = (struct file *)arg0;
	$CB
}

	kretprobe:nfsd_read
	/@nfsd_read_rqstp[tid] != 0/
	{
		\$rqstp = @nfsd_read_rqstp[tid];
		\$uid = \$rqstp->rq_cred.cr_uid.val;
		\$gid = \$rqstp->rq_cred.cr_gid.val;
		\$countp = @nfsd_read_countp[tid];
		\$bytes = *\$countp;

		\$client_ip4 = @nfsd_read_client[tid];
		\$client_ip4num = (uint32)(\$client_ip4 >> 24 |
			(\$client_ip4 >> 16 & 0xFF) << 8 |
			(\$client_ip4 >> 8 & 0xFF) << 16 |
			(\$client_ip4 & 0xFF) << 24);

		\$server_ip4 = @nfsd_read_server[tid];
		\$server_ip4num = (uint32)(\$server_ip4 >> 24 |
			(\$server_ip4 >> 16 & 0xFF) << 8 |
			(\$server_ip4 >> 8 & 0xFF) << 16 |
			(\$server_ip4 & 0xFF) << 24);

		delete(@nfsd_read_client[tid]);
		delete(@nfsd_read_countp[tid]);
		delete(@nfsd_read_rqstp[tid]);
		delete(@nfsd_read_server[tid]);

		\$filtered = 0;

		// ST: FILTERS
${FILTER_CLIENT:+
		if (\$client_ip4num != $FILTER_CLIENT) { \$filtered = 1; $CB
}
${FILTER_GROUP:+
		if (\$gid != $FILTER_GROUP) { \$filtered = 1; $CB
}
${FILTER_SERVER:+
		if (\$server_ip4num != $FILTER_SERVER) { \$filtered = 1; $CB
}
${FILTER_USER:+
		if (\$uid != $FILTER_USER) { \$filtered = 1; $CB
}

		if (\$filtered == 0)
		{
			// ST: VIEWS TRACEDATA
${VIEW_CLIENT:+
			@rd_client[ntop(AF_INET, \$client_ip4)] = sum(\$bytes);
}

${VIEW_FILE:+
			\$file = @nfsd_read_filep[tid];
			\$de = \$file->f_dentry;
			\$n1 = \$de->d_name.name;
			\$de = \$de->d_parent;
			\$n2 = \$de->d_name.name;

			@rd_file[str(\$n2), str(\$n1)] = sum(\$bytes);
}

${VIEW_GROUP:+
			@rd_group[\$gid] = sum(\$bytes);
}

${VIEW_SERVER:+
			@rd_server[ntop(AF_INET, \$server_ip4)] = sum(\$bytes);
}

${VIEW_USER:+
			@rd_user[\$uid] = sum(\$bytes);
}
		$CB

${VIEW_FILE:+
		delete(@nfsd_read_filep[tid]);
}
	$CB
}

	////////////////////////////////////////////////// WRITE PROBES

	/*
	 * write(2) probes
	 */

${MODE_DATA:+
	kprobe:nfsd_write
	{
		\$rqstp = (struct svc_rqst *)arg0;
		@nfsd_write_rqstp[tid] = \$rqstp;
		@nfsd_write_countp[tid] = arg5;
		\$data = (int64 *)\$rqstp->rq_addr.__data;
		\$num = (int64)*\$data;
		@nfsd_write_client[tid] = \$num >> 16 & 0xFFFFFFFF;
		\$data = (int64 *)\$rqstp->rq_daddr.__data;
		\$num = (int64)*\$data;
		@nfsd_write_server[tid] = \$num >> 16 & 0xFFFFFFFF;
	$CB

${VIEW_FILE:+
	kprobe:nfsd_vfs_write
	/@nfsd_write_rqstp[tid] != 0/
	{
		@nfsd_write_filep[tid] = (struct file *)arg2;
	$CB
}

	kretprobe:nfsd_write
	/@nfsd_write_rqstp[tid] != 0/
	{
		\$rqstp = @nfsd_write_rqstp[tid];
		\$uid = \$rqstp->rq_cred.cr_uid.val;
		\$gid = \$rqstp->rq_cred.cr_gid.val;
		\$countp = @nfsd_write_countp[tid];
		\$bytes = *\$countp;

		\$client_ip4 = @nfsd_write_client[tid];
		\$client_ip4num = (uint32)(\$client_ip4 >> 24 |
			(\$client_ip4 >> 16 & 0xFF) << 8 |
			(\$client_ip4 >> 8 & 0xFF) << 16 |
			(\$client_ip4 & 0xFF) << 24);

		\$server_ip4 = @nfsd_write_server[tid];
		\$server_ip4num = (uint32)(\$server_ip4 >> 24 |
			(\$server_ip4 >> 16 & 0xFF) << 8 |
			(\$server_ip4 >> 8 & 0xFF) << 16 |
			(\$server_ip4 & 0xFF) << 24);

		delete(@nfsd_write_client[tid]);
		delete(@nfsd_write_countp[tid]);
		delete(@nfsd_write_rqstp[tid]);
		delete(@nfsd_write_server[tid]);

		\$filtered = 0;

		// ST: FILTERS
${FILTER_CLIENT:+
		if (\$client_ip4num != $FILTER_CLIENT) { \$filtered = 1; $CB
}
${FILTER_GROUP:+
		if (\$gid != $FILTER_GROUP) { \$filtered = 1; $CB
}
${FILTER_SERVER:+
		if (\$server_ip4num != $FILTER_SERVER) { \$filtered = 1; $CB
}
${FILTER_USER:+
		if (\$uid != $FILTER_USER) { \$filtered = 1; $CB
}

		if (\$filtered == 0)
		{
			// ST: VIEWS TRACEDATA
${VIEW_CLIENT:+
			@wr_client[ntop(AF_INET, \$client_ip4)] = sum(\$bytes);
}

${VIEW_FILE:+
			\$file = @nfsd_write_filep[tid];
			\$de = \$file->f_dentry;
			\$n1 = \$de->d_name.name;
			\$de = \$de->d_parent;
			\$n2 = \$de->d_name.name;

			@wr_file[str(\$n2), str(\$n1)] = sum(\$bytes);
}

${VIEW_GROUP:+
			@wr_group[\$gid] = sum(\$bytes);
}

${VIEW_SERVER:+
			@wr_server[ntop(AF_INET, \$server_ip4)] = sum(\$bytes);
}

${VIEW_USER:+
			@wr_user[\$uid] = sum(\$bytes);
}
		$CB

${VIEW_FILE:+
		delete(@nfsd_write_filep[tid]);
}
	$CB
}

	////////////////////////////////////////////////// INTERVAL PROBE

	$INTERVAL_PROBE
	{
		time("time|%s\n");
		printf("===\n");

${VIEW_CLIENT:+
	${MODE_DATA:+
		print(@rd_client);
		print(@wr_client);
		clear(@rd_client);
		clear(@wr_client);
	}
	${MODE_META:+
		print(@stat_fail_client);
		print(@stat_good_client);
		clear(@stat_fail_client);
		clear(@stat_good_client);
	}
}
${VIEW_FILE:+
	${MODE_DATA:+
		print(@rd_file);
		print(@wr_file);
		clear(@rd_file);
		clear(@wr_file);
	}
	${MODE_META:+
		print(@stat_fail_file);
		print(@stat_good_file);
		clear(@stat_fail_file);
		clear(@stat_good_file);
	}
}
${VIEW_GROUP:+
	${MODE_DATA:+
		print(@rd_group);
		print(@wr_group);
		clear(@rd_group);
		clear(@wr_group);
	}
	${MODE_META:+
		print(@stat_fail_group);
		print(@stat_good_group);
		clear(@stat_fail_group);
		clear(@stat_good_group);
	}
}
${VIEW_SERVER:+
	${MODE_DATA:+
		print(@rd_server);
		print(@wr_server);
		clear(@rd_server);
		clear(@wr_server);
	}
	${MODE_META:+
		print(@stat_fail_server);
		print(@stat_good_server);
		clear(@stat_fail_server);
		clear(@stat_good_server);
	}
}
${VIEW_USER:+
	${MODE_DATA:+
		print(@rd_user);
		print(@wr_user);
		clear(@rd_user);
		clear(@wr_user);
	}
	${MODE_META:+
		print(@stat_fail_user);
		print(@stat_good_user);
		clear(@stat_fail_user);
		clear(@stat_good_user);
	}
}

		printf("---\n");
	}

	////////////////////////////////////////////////// END

	END
	{
${VIEW_CLIENT:+
	${MODE_DATA:+
		clear(@rd_client);
		clear(@wr_client);
	}
	${MODE_META:+
		clear(@stat_fail_client);
		clear(@stat_good_client);
	}
}
${VIEW_FILE:+
	${MODE_DATA:+
		clear(@nfsd_read_filep);
		clear(@nfsd_write_filep);
		clear(@rd_file);
		clear(@wr_file);
	}
	${MODE_META:+
		clear(@nfsd_getattr_filep);
		clear(@stat_fail_file);
		clear(@stat_good_file);
	}
}
${VIEW_GROUP:+
	${MODE_DATA:+
		clear(@rd_group);
		clear(@wr_group);
	}
	${MODE_META:+
		clear(@stat_fail_group);
		clear(@stat_good_group);
	}
}
${VIEW_USER:+
	${MODE_DATA:+
		clear(@rd_user);
		clear(@wr_user);
	}
	${MODE_META:+
		clear(@stat_fail_user);
		clear(@stat_good_user);
	}
}
${VIEW_SERVER:+
	${MODE_DATA:+
		clear(@rd_server);
		clear(@wr_server);
	}
	${MODE_META:+
		clear(@stat_fail_server);
		clear(@stat_good_server);
	}
}

${MODE_DATA:+
		clear(@nfsd_read_client);
		clear(@nfsd_read_countp);
		clear(@nfsd_read_rqstp);
		clear(@nfsd_read_server);
		clear(@nfsd_write_client);
		clear(@nfsd_write_countp);
		clear(@nfsd_write_rqstp);
		clear(@nfsd_write_server);
}
${MODE_META:+
		clear(@nfsd_getattr_client);
		clear(@nfsd_getattr_rqstp);
		clear(@nfsd_getattr_server);
}
	}

	//////////////////////////////////////////////////////////////////////
	// END
	//////////////////////////////////////////////////////////////////////
EOF
	pid=$!

	#
	# Identify child bpftrace
	#
	if [ ! "$DEBUG" ]; then
		info "Waiting for bpftrace to initialize..."
		while kill -0 $pid 2> /dev/null; do
			bpid=$( pgrep -P $pid bpftrace ) && break
			sleep 1
		done
		if ! kill -0 $pid 2> /dev/null; then
			wait $pid > /dev/null 2>&1 # Collect exit status
			echo EXIT:$? # Send status to post-processor
			exit
		fi
	fi

	#
	# Wait on background (bpftrace) child
	#
	status_collected=
	while kill -0 $bpid > /dev/null 2>&1; do
		wait > /dev/null 2>&1 # Collect exit status
		[ "$status_collected" ] || status_collected=$?
	done
	echo EXIT:$status_collected # Send status to post-processor

} | awk -v color=${COLOR:-0} \
	-v cols=$cols \
	-v cons=${CONS:-0} \
	-v data_mode=${MODE_DATA:-0} \
	-v debug=${DEBUG:-0} \
	-v debugger=${DEBUGGER:-0} \
	-v filter_file="$FILTER_FILE" \
	-v group_map="$GROUP_MAP" \
	-v interval=$INTERVAL_SECONDS \
	-v ip_map="$IP_MAP" \
	-v meta_mode=${MODE_META:-0} \
	-v mode="$MODE" \
	-v no_names=${NO_NAMES:-0} \
	-v nsamples=${NSAMPLES:-0} \
	-v output_json=${OUTPUT_JSON:-0} \
	-v quiet=${QUIET:-0} \
	-v passwd_map="$PASSWD_MAP" \
	-v raw_view=${RAW_VIEW:-0} \
	-v redact=${REDACT:-0} \
	-v rows=$rows \
	-v show_basic=${SHOW_BASIC:-0} \
	-v sort="$SORT" \
	-v stderr=/dev/stderr \
	-v view="$VIEW" \
	-v wide_view=${WIDE_VIEW:-0} \
	'####################################### BEGIN

	# ST: POST

	BEGIN {
		debug2("Terminal size (rows, cols) = (%d, %d)", rows, cols)

		exit_status = 0 # SUCCESS
		time_delta = 0 # Calculated
		samples_left = nsamples
		tm = systime()

		inv	= "\033[7m"
		noinv	= "\033[27m"
		bold    = "\033[1m"
		nobold  = "\033[22m"
		red     = "\033[31m"
		green   = "\033[32m"
		yellow  = "\033[33m"
		magenta = "\033[35m"
		cyan    = "\033[36m"
		fgreset = "\033[39m"

		# Obtain current process (awk) pid
		(cmd = "echo $PPID") | getline apid
		close(cmd)

		# Obtain parent process (sh) pid
		getline stat < (file = sprintf("/proc/%d/stat", apid))
		close(file)
		split(stat, st)
		spid = st[4]

		# Obtain parent process (sh) name
		getline stat < (file = sprintf("/proc/%d/stat", spid))
		close(file)
		split(stat, st)
		comm = st[2]
		if (match(comm, /^\(.*\)$/))
			comm = substr(comm, 2, length(comm) - 2)

		# Obtain child (sh) pid
		(cmd = sprintf("pgrep -P %d %s", spid, comm)) | getline cpid
		close(cmd)

		if (!raw_view) {
			clear_data()
			resize()
			if (!no_names) load_files()
		}

		# Declare arrays
		delete times

		if (redact) {
			m = "^(USER|total|"
			if ((u = ENVIRON["USER"]) != "")
				m = m u "|"
			if ((s = ENVIRON["SUDO_USER"]) != "" && s != u)
				m = m s "|"
			cmd = "getent passwd 2> /dev/null"
			while (cmd | getline > 0) {
				if (split($0, f, /:/) < 3) continue
				if (f[3] > 1024 && f[3] !~ /^6553[456]$/)
					continue
				m = m f[1] "|"
			}
			close(cmd)
			m = m "\\*)$"
			unredacted_users = m

			m = "^(GROUP|total|"
			cmd = "getent group 2> /dev/null"
			while (cmd | getline > 0) {
				if (split($0, f, /:/) < 3) continue
				if (f[3] > 1024 && f[3] !~ /^6553[456]$/)
					continue
				m = m f[1] "|"
			}
			close(cmd)
			m = m "\\*)$"
			unredacted_groups = m

			unredacted_clients = "^(CLIENT|total|\\*)$"
			unredacted_servers = "^(SERVER|total|\\*)$"
			unredacted_files = "^(FILE|total|\\*)$"
		}
	}

	######################################## FUNCTIONS

	function bpftrace_init()
	{
		# Obtain handler (sh) pid
		(cmd = sprintf("pgrep -P %d %s", cpid, comm)) | getline wpid

		# Obtain bpftrace pid
		cmd = sprintf("pgrep -P %d bpftrace", wpid)
		cmd | getline bpid
		close(cmd)
	}

	function debug1(fmt,a1) { if (debugger) printf fmt "\n", a1 }
	function debug2(fmt,a1,a2) { if (debugger) printf fmt "\n", a1, a2 }
	function debug3(fmt,a1,a2,a3) {
		if (debugger) printf fmt "\n", a1, a2, a3
	}
	function buffer_add(text) { BUFFER = BUFFER text }

	function print_buffer()
	{
		if (!cons && !output_json) buffer_add("\n")
		printf "%s", BUFFER
		fflush()
	}

	function info(str)
	{
		if (quiet) return
		printf "%sINFO%s %s\n", color ? magenta : "",
			color ? fgreset : "", str > stderr
		fflush(stderr)
	}

	function get_random(len,        c, n, r, rdata, rfile, rlen)
	{
		if (len < 1) return ""
		rlen = 0
		rdata = ""
		rfile = "/dev/urandom"
		while (length(rdata) < len && getline r < rfile > 0) {
			for (n = split(r, c, ""); n >= 1; n--) {
				if (c[n] !~ /[\x41-\x5a]/) continue
				rdata = rdata c[n]
				if (++rlen == len) break
			}
		}
		close(rfile)
		return rdata
	}

	function resize(        dsz, vsz, vsz_fixed, bar_size_fixed,
		bar_size_fixed_max, bar_size_fixed_min, bar_min1, bar_min2,
		vsz_cols1, vsz_cols2, vsz_max, vsz_min, wv)
	{
		if (output_json) return

		#
		# Calculate columns and column widths
		# ST: VIEWS
		#
		# NB: bar_size = size of bar column (if shown)
		# NB: dsz = size of TOTAL, READ(OUT), WRITE(IN), STAT(GOOD),
		#     and STAT(FAIL) data columns
		# NB: vsz = size of VIEW column ("view size")
		#
		# If given -w (wide view) make bar_size fixed-width and
		# vsz variable-width.
		#
		# Without -w, make vsz fixed-width and bar_size variable.
		#

		wv = wide_view

		show_bar_column = 1
		if (mode == "data") {
			show_rw_columns = 1
			show_stat_columns = 0
		} else if (mode == "meta") {
			show_rw_columns = 0
			show_stat_columns = 1
		}

		vsz_min = view == "FILE" ? length("total") : length(view)
		vsz_max = 15

		dsz = show_basic ? 10 : 12
		bar_size_fixed_max = 21
		bar_size_fixed_min = 11

		#
		# Calculate minimum terminal width required (bar_min1)
		# to display small bar (bar_size_fixed_min) and also
		# minimum terminal width required (bar_min2) to display
		# larger bar (bar_size_fixed_max).
		#
		bar_min1 = 0
		bar_min1 += vsz_min + 1 # VIEW + space
		bar_min1 += dsz + 1 # TOTAL + space
		vsz_cols2 = bar_min1
		bar_min1 += dsz + 1 # WRITE(IN) + space
		vsz_cols1 = bar_min2 = bar_min1
		bar_min1 += bar_size_fixed_min + 1 # small bar + space
		bar_min2 += bar_size_fixed_max + 1 # bigger bar + space
		bar_min1 += dsz # READ(OUT)
		bar_min2 += dsz # READ(OUT)
		vsz_cols1 += dsz # READ(OUT)

		#
		# Calculate fixed bar width based on terminal width
		# NB: Only used in wide-view (-w)
		# NB: If terminal is too narrow, disable bar/columns
		#
		if (cols >= bar_min2) {
			bar_size_fixed = bar_size_fixed_max
		} else if (cols >= bar_min1) {
			bar_size_fixed = bar_size_fixed_min
		} else {
			show_bar_column = 0
			bar_size_fixed = 0
		}

		#
		# Calculate fixed-size "VIEW" column width
		# NB: Unused in wide-view (-w)
		#
		vsz_fixed = vsz_min
		if (cols >= bar_min2) {
			vsz_fixed += cols - bar_min2
			if (vsz_fixed > vsz_max)
				vsz_fixed = vsz_max
		} else if (cols >= bar_min1) {
			vsz_fixed += cols - bar_min1
			if (vsz_fixed > vsz_max)
				vsz_fixed = vsz_max
		} else if (cols >= vsz_cols1) {
			vsz_fixed += cols - vsz_cols1
		} else if (cols >= vsz_cols2) {
			if (mode == "data") {
				show_rw_columns = 0
			} else if (mode == "meta") {
				show_stat_columns = 0
			}
			wv = 1
		} else {
			if (mode == "data") {
				show_rw_columns = 0
			} else if (mode == "meta") {
				show_stat_columns = 0
			}
		}

		if (wv) {
			# Fixed-width
			bar_size = bar_size_fixed

			# Variable-width (%-*s)
			vsz = cols
			vsz -= 0 + 1 # %-*s VIEW + space
			vsz -= dsz # TOTAL
			if (show_rw_columns || show_stat_columns) {
				# space + WRITE(IN)/STAT(GOOD) + space
				vsz -= 1 + dsz + 1

				if (bar_size > 0) {
					vsz -= bar_size + 1 # bar + space
				}
				vsz -= dsz # READ(OUT)/STAT(FAIL)
			}
		} else if (show_bar_column) {
			# Fixed-width
			vsz = vsz_fixed

			# Variable-width (%-*s)
			bar_size = cols
			bar_size -= vsz + 1 # %[-]*s VIEW + space
			bar_size -= dsz + 1 # TOTAL + space
			bar_size -= dsz + 1 # WRITE(IN)/STAT(GOOD) + space
			bar_size -= 0 + 1 # variable-width bar + space
			bar_size -= dsz # READ(OUT)/STAT(FAIL)
		} else {
			# Fixed-width
			vsz = vsz_fixed
		}

		#
		# Calculate format and line width
		# ST: VIEWS
		#

		fmt = ""
		fmtsz = 0

		fmt = fmt " %-" vsz "s" # VIEW
		fmtsz += 1 + vsz
		fmt = fmt " %" dsz "s" # TOTAL
		fmtsz += 1 + dsz
		if (color) {
			fmt = fmt " " red "%" dsz "s" # WRITE(IN)/STAT(FAIL)
		} else {
			fmt = fmt " %" dsz "s" # WRITE(IN)/STAT(GOOD)
		}
		fmtsz += 1 + dsz

		if (show_bar_column) {
			full_bar = bar_size
			bar_size = int(bar_size / 2)
			if (bar_size * 2 == full_bar) bar_size--
			fmt = fmt " %*s" # write_bar
			# read/fail bar
			if (color) {
				fmt = fmt fgreset "|" cyan "%-*s"
			} else {
				fmt = fmt "|%-*s"
			}
			fmtsz += 1 + bar_size + 1 + bar_size
			fmt = fmt " %-" dsz "s" # READ(OUT)/STAT(FAIL)
			fmtsz += 1 + dsz
		} else if (show_rw_columns || show_stat_columns) {
			# READ(OUT)/STAT(FAIL)
			if (color) {
				fmt = fmt " " cyan "%" dsz "s"
			} else {
				fmt = fmt " %" dsz "s"
			}
			fmtsz += 1 + dsz
		}

		fmt = substr(fmt, 2) # Trim leading space
		fmtsz -= 1
		fmt = fmt (color ? fgreset : "") "\n"

		#
		# Export calculated column sizes for things we truncate
		#
		delete csz
		csz["view"] = vsz

		#
		# Redraw console
		#
		if (cons) {
			clear_buffer()
			buffer_add_data()
			print_buffer()
		}
	}

	function clear_data()
	{
		# ST: VIEWS
		delete client_keys
		delete file_keys
		delete group_keys
		delete server_keys
		delete user_keys

		nviews = 0
		delete map_views
		delete view_list

		if (data_mode) {
			delete map_key_read
			delete map_key_write
			delete map_view_read
			delete map_view_write
		}
		if (meta_mode) {
			delete map_key_stat_good
			delete map_key_stat_fail
			delete map_view_stat_good
			delete map_view_stat_fail
		}
	}

	function clear_buffer()
	{
		BUFFER = ""
		if (output_json) return
		if (!debugger && cons)
			buffer_add(sprintf("\033[H\033[J"))
		buffer_add_header()
	}

	function buffer_add1(arg1, total, value1, bar1, bar2,
		value2, prefix, suffix,        str)
	{
		if (redact && view == "USER") {
			if (arg1 !~ unredacted_users)
				arg1 = get_random(length(arg1))
		} else if (redact && view == "GROUP") {
			if (arg1 !~ unredacted_groups)
				arg1 = get_random(length(arg1))
		} else if (redact && view == "CLIENT") {
			if (arg1 !~ unredacted_clients)
				arg1 = get_random(length(arg1))
		} else if (redact && view == "SERVER") {
			if (arg1 !~ unredacted_servers)
				arg1 = get_random(length(arg1))
		} else if (redact && view == "FILE") {
			if (arg1 !~ unredacted_files)
				arg1 = get_random(length(arg1))
		}
		if (length(arg1) > csz["view"]) {
			if (view == "FILE")
				arg1 = "..." substr(arg1,
					length(arg1) - csz["view"] + 4)
			else
				arg1 = substr(arg1, 1, csz["view"])
		}

		if (show_bar_column) {
			str = sprintf(fmt, arg1, total, value2, bar_size,
				bar2, bar_size, bar1, value1)
		} else {
			str = sprintf(fmt, arg1, total, value2, value1)
		}
		if (cols < fmtsz) {
			str = substr(str, 1, cols) (str ~ /\n$/ ? "\n" : "")
		}
		buffer_add(prefix str suffix)
	}

	function buffer_add_header(        prefix, suffix,
		presz, n, fmt, dtfmt, dtsz, ifmt, sz, str)
	{
		if (output_json) return
		ifmt = "%.3fs"
		presz = 9 + 1 + length(sprintf(ifmt, interval))
			#  9 = "Interval:"
			#  1 = number of spaces
		sz = cols < fmtsz ? cols : fmtsz
		for (n = split("|%T|%F %T|%c", fmt, /\|/); n > 0; n--) {
			dtfmt = fmt[n]
			dtsz = dtfmt == "" ? 0 : length(strftime(dtfmt, tm))
			if (sz >= presz + 1 + dtsz) break
		}
		if (dtfmt == "") {
			str = sprintf("Interval: " ifmt, interval)
			if (length(str) > sz) {
				str = substr(str, 1, sz)
			}
			buffer_add(str "\n")
		} else {
			buffer_add(sprintf("Interval: %-*s %*s\n",
				sz - 9 - 2 - dtsz, sprintf(ifmt, interval),
				dtsz, strftime(dtfmt, tm)))
					#  9 = "Interval:"
					#  2 = number of spaces
		}
		prefix = color ? inv green : ""
		suffix = color ? fgreset noinv : ""
		empty_bar = ""
		# ST: VIEWS
		if (mode == "data") {
			colnam1 = "READ(OUT)"
			colnam2 = "WRITE(IN)"
		} else if (mode == "meta") {
			colnam1 = "STAT(GOOD)"
			colnam2 = "STAT(FAIL)"
		}
		buffer_add1(view, "TOTAL",
			colnam1, empty_bar, empty_bar, colnam2,
			prefix, suffix)
	}

	function buffer_add_data()
	{
		#
		# Process each requested view
		#
		for (v = 1; v <= nviews; v++)
			process_view(view_list[v])
	}

	function load_files()
	{
		delete uid2name
		while (getline < passwd_map > 0) {
			n = split($0, fields, /:/)
			uid2name[fields[3]] = fields[1]
		}
		close(passwd_map)

		delete gid2name
		while (getline < group_map > 0) {
			n = split($0, fields, /:/)
			gid2name[fields[3]] = fields[1]
		}
		close(group_map)

		delete ip2name
		while (getline < ip_map > 0) {
			if (/^[[:space:]]*(#|$)/) continue
			n = split($0, fields, /[[:space:]]+/)
			ip2name[fields[1]] = fields[2]
		}
		close(ip_map)
	}

	function load_keys(map_view,        map_key)
	{
		delete _keys
		# ST: VIEWS
		if (map_view == "client") for (map_key in client_keys)
			_keys[map_key] = client_keys[map_key]
		else if (map_view == "file") for (map_key in file_keys)
			_keys[map_key] = file_keys[map_key]
		else if (map_view == "group") for (map_key in group_keys)
			_keys[map_key] = group_keys[map_key]
		else if (map_view == "server") for (map_key in server_keys)
			_keys[map_key] = server_keys[map_key]
		else if (map_view == "user") for (map_key in user_keys)
			_keys[map_key] = user_keys[map_key]
	}

	function parse_map()
	{
		# ST: TRACEDATA
		if (!match($0, /^@[^\[]*\[/)) return 0
		map_name = substr($0, RSTART + 1, RLENGTH - 2)
		if (map_name ~ /^(rd_|wr_)/) {
			map_view = substr(map_name, 4)
			map_op = substr(map_name, 1, 2) # rd/wr
		} else if (map_name ~ /^(stat_fail_|stat_good_)/) {
			map_view = substr(map_name, 11)
			map_op = substr(map_name, 1, 9)
		} else {
			map_view = ""
			map_op = ""
		}
		debug2("+ map_view=[%s] map_op=[%s]", map_view, map_op)

		if (!match($0, /\[.*\]:/)) return 0
		map_key = substr($0, RSTART + 1, RLENGTH - 3)
		map_value = $NF

		#
		# ST: FILTERS
		#

		if (map_view == "file") {
			gsub(/, /, "/", map_key)
			gsub("//+", "/", map_key)
			if (filter_file != "" && map_key !~ filter_file) return 0
		}

		#
		# ST: VIEWS
		#

		if (!(map_view in map_views)) {
			map_views[map_view]
			view_list[++nviews] = map_view
		}
		if (map_view == "client") client_keys[map_key]
		else if (map_view == "file") file_keys[map_key]
		else if (map_view == "group") group_keys[map_key]
		else if (map_view == "server") server_keys[map_key]
		else if (map_view == "user") user_keys[map_key]

		#
		# ST: OPS
		#

		if (map_op == "rd") {
			debug2("++ map_view_read[%s] += %d",
				map_view, map_value)
			map_view_read[map_view] += map_value

			debug3("++ map_key_read[%s, %s] += %d",
				map_view, map_key, map_value)
			map_key_read[map_view, map_key] = map_value
		} else if (map_op == "wr") { # wr
			debug2("++ map_view_write[%s] += %d",
				map_view, map_value)
			map_view_write[map_view] += map_value

			debug3("++ map_key_write[%s, %s] += %d",
				map_view, map_key, map_value)
			map_key_write[map_view, map_key] = map_value
		} else if (map_op == "stat_good") {
			debug2("++ map_view_stat_good[%s] += %d",
				map_view, map_value)
			map_view_stat_good[map_view] += map_value

			debug3("++ map_key_stat_good[%s, %s] += %d",
				map_view, map_key, map_value)
			map_key_stat_good[map_view, map_key] = map_value
		} else if (map_op == "stat_fail") {
			debug2("++ map_view_stat_fail[%s] += %d",
				map_view, map_value)
			map_view_stat_fail[map_view] += map_value

			debug3("++ map_key_stat_fail[%s, %s] += %d",
				map_view, map_key, map_value)
			map_key_stat_fail[map_view, map_key] = map_value
		}

		return 1
	}

	function humanize(value,
		raw, n, suffix, suffixes, div, fmt, unit)
	{
		raw = value
		if (mode == "data") {
			div = 1024
			fmt = "%'"'"'.2f%s%s"
			unit = show_basic ? "B" : "B/s"
		} else if (mode == "meta") {
			div = 1000
			fmt = "%'"'"'.1f%s%s"
			unit = show_basic ? "" : "/s"
		}
		n = split(",K,M,G,T,E", suffixes, /,/)
		for (suffix = 1; suffix <= n; suffix++) {
			if (int(value) < div) break
			value /= div
		}
		if (v ~ /\./) sub(/\.?0+$/, "", v)
		value = sprintf(fmt, value, suffixes[suffix], unit)
		return value
	}

	function _asort(src, dest,        k, nitems, i, val)
	{
		k = nitems = 0
		for (i in src) dest[++nitems] = src[i]
		for (i = 1; i <= nitems; k = i++) {
			val = dest[i]
			while ((k > 0) && (dest[k] > val)) {
				dest[k+1] = dest[k]; k--
			}
			dest[k+1] = val
		}
		return nitems
	}

	function json_add(json, key, format, value)
	{
		return json (length(json) < 2 ? "" : ",") \
			sprintf("\"%s\":" format, key, value)
	}

	function json_add_str(json, key, value)
	{
		return json_add(json, key, "\"%s\"", value)
	}

	function json_add_uint(json, key, value)
	{
		return json_add(json, key, "%u", value)
	}

	function json_add_prec(json, key, precision, value,        x)
	{
		x = sprintf("%.*f", precision, value)
		if (x ~ /\./) sub(/\.?0+$/, "", x)
		return json_add(json, key, "%s", x)
	}

	function json_add_float(json, key, value)
	{
		return json_add_prec(json, key, 12, value)
	}

	function sample_check()
	{
		if (nsamples > 0 && --samples_left < 1) {
			if (bpid == "") {
				cmd = sprintf("pgrep -P %d bpftrace", cpid)
				cmd | getline bpid
				close(cmd)
			}
			if (bpid != "") {
				system(sprintf("kill %d > /dev/null 2>&1",
					bpid))
			}
			if (more) printf "\n"
			exit
		}
	}

	function process_view(curview,
		read_bar, read_rate, read_total,
		write_bar, write_rate, write_total,
		rw_rate, rw_total,
		stat_good_bar, stat_good_rate,
		stat_fail_bar, stat_fail_rate,
		stat_all_rate, stat_all_total,
		_keys_sorted, cred, i, v, r, n, table_rows)
	{
		time_delta = times[2] - times[1]
		if (time_delta < 1) time_delta = 1 # prevent division-by-0
		debug1("Time delta is %d seconds", time_delta)

		if (data_mode) {
			read_total = map_view_read[curview]
			read_rate = read_total / time_delta
			read_bar = ""

			write_total = map_view_write[curview]
			write_rate = write_total / time_delta
			write_bar = ""

			rw_total = read_total + write_total
			rw_rate = rw_total / time_delta
		}

		if (meta_mode) {
			stat_good_total = map_view_stat_good[curview]
			stat_good_rate = stat_good_total / time_delta
			stat_good_bar = ""

			stat_fail_total = map_view_stat_fail[curview]
			stat_fail_rate = stat_fail_total / time_delta
			stat_fail_bar = ""

			stat_all_total = stat_good_total + stat_fail_total
			stat_all_rate = stat_all_total / time_delta
		}

		if (output_json) {
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out,
				"ident", "total_" curview)
			if (data_mode) {
				json_out = json_add_uint(json_out,
					"total_bytes", rw_total)
				json_out = json_add_float(json_out,
					"total_rate", rw_rate)
				json_out = json_add_uint(json_out,
					"read_bytes", read_total)
				json_out = json_add_float(json_out,
					"read_rate", read_rate)
				json_out = json_add_uint(json_out,
					"write_bytes", write_total)
				json_out = json_add_float(json_out,
					"write_rate", write_rate)
			}
			if (meta_mode) {
				json_out = json_add_uint(json_out,
					"stat_total", stat_all_total)
				json_out = json_add_float(json_out,
					"stat_rate", stat_all_rate)
				json_out = json_add_uint(json_out,
					"stat_good_total", stat_good_total)
				json_out = json_add_float(json_out,
					"stat_good_rate", stat_good_rate)
				json_out = json_add_uint(json_out,
					"stat_fail_total", stat_fail_total)
				json_out = json_add_float(json_out,
					"stat_fail_rate", stat_fail_rate)
			}
			buffer_add("{" json_out "}\n")
		} else if (show_basic && mode == "data") {
			# ST: VIEWS
			buffer_add1("total",
				humanize(rw_total),
				humanize(read_total), read_bar,
				write_bar, humanize(write_total))
		} else if (show_basic && mode == "meta") {
			# ST: VIEWS
			buffer_add1("total",
				humanize(stat_all_total),
				humanize(stat_good_total),
				stat_good_bar, stat_fail_bar,
				humanize(stat_fail_total))
		} else if (mode == "data") {
			# ST: VIEWS
			buffer_add1("total",
				humanize(rw_rate),
				humanize(read_rate),
				read_bar, write_bar,
				humanize(write_rate))
		} else if (mode == "meta") {
			# ST: VIEWS
			buffer_add1("total",
				humanize(stat_all_rate),
				humanize(stat_good_rate),
				stat_good_bar, stat_fail_bar,
				humanize(stat_fail_rate))
		}

		#
		# Decorate combined read/write values
		# ST: SORTING
		#
		load_keys(curview)
		for (cred in _keys) {
			if (sort == "read") {
				v = int(map_key_read[curview, cred])
			} else if (sort == "write") {
				v = int(map_key_write[curview, cred])
			} else if (sort == "good") {
				v = int(map_key_stat_good[curview, cred])
			} else if (sort == "fail") {
				v = int(map_key_stat_fail[curview, cred])
			} else { # total
				v = 0
				if (data_mode) {
					v += map_key_read[curview, cred]
					v += map_key_write[curview, cred]
				}
				if (meta_mode) {
					v += map_key_stat_good[curview, cred]
					v += map_key_stat_fail[curview, cred]
				}
				v = int(v)
			}
			_keys[cred] = sprintf("%99d %s", v, cred)
		}

		#
		# Print subtotals
		#
		r = 1
		n = _asort(_keys, _keys_sorted)
		table_rows = output_json || !cons ? n : rows - 4
		for (i = n; i >= 1 && r <= table_rows; i--) {
			debug2("r=[%d] table_rows=[%d]", r, table_rows)
			cred = _keys_sorted[i]
			sub(/^ *[^ ]+ +/, "", cred) # Undecorate
			r += process_cred(curview, cred)
		}
		if (more = i > 0) buffer_add(sprintf("%s(%d more) ... %s",
			color ? inv bold yellow : "", i,
			color ? noinv nobold fgreset : ""))
	}

	function process_cred(curview, cred,
		read_total, write_total,
		cred_read, read_bar, read_bar_pct, read_bar_size, read_rate,
		cred_write, write_bar, write_bar_pct, write_bar_size,
		write_rate, cred_rw, rw_rate, pch, _cred,
		good_total, fail_total,
		cred_good, good_bar, good_bar_pct, good_bar_size, good_rate,
		cred_fail, fail_bar, fail_bar_pct, fail_bar_size,
		fail_rate, cred_total, total_rate)
	{
		pch = "="
		debug1("-> process_cred(curview = %s, ...)", curview)
		debug1("+ cred=[%s]", cred)

		if (data_mode) {
			read_total = map_view_read[curview]
			write_total = map_view_write[curview]

			cred_read = map_key_read[curview, cred]
			cred_write = map_key_write[curview, cred]
			cred_rw = cred_read + cred_write

			read_rate = cred_read / time_delta
			if (read_total > 0)
				read_bar_pct = cred_read / read_total
			else
				read_bar_pct = 0
			read_bar_size = bar_size * read_bar_pct
			read_bar = sprintf("%*s", read_bar_size, "")
			gsub(/ /, pch, read_bar)
			sub(/.$/, ">", read_bar)

			write_rate = cred_write / time_delta
			if (write_total > 0)
				write_bar_pct = cred_write / write_total
			else
				write_bar_pct = 0
			write_bar_size = bar_size * write_bar_pct
			write_bar = sprintf("%*s", write_bar_size, "")
			gsub(/ /, pch, write_bar)
			sub(/^./, "<", write_bar)
		}

		if (meta_mode) {
			good_total = map_view_stat_good[curview]
			fail_total = map_view_stat_fail[curview]

			cred_good = map_key_stat_good[curview, cred]
			cred_fail = map_key_stat_fail[curview, cred]
			cred_total = cred_good + cred_fail

			good_rate = cred_good / time_delta
			if (good_total > 0)
				good_bar_pct = cred_good / good_total
			else
				good_bar_pct = 0
			good_bar_size = bar_size * good_bar_pct
			good_bar = sprintf("%*s", good_bar_size, "")
			gsub(/ /, pch, good_bar)
			sub(/.$/, ">", good_bar)

			fail_rate = cred_fail / time_delta
			if (fail_total > 0)
				fail_bar_pct = cred_fail / fail_total
			else
				fail_bar_pct = 0
			fail_bar_size = bar_size * fail_bar_pct
			fail_bar = sprintf("%*s", fail_bar_size, "")
			gsub(/ /, pch, fail_bar)
			sub(/^./, "<", fail_bar)
		}

		if (!no_names) {
			_cred = cred
			if (curview == "client" || curview == "server") {
				if (cred in ip2name) cred = ip2name[cred]
			} else if (curview == "group") {
				if (cred in gid2name) cred = gid2name[cred]
			} else if (curview == "user") {
				if (cred in uid2name) cred = uid2name[cred]
			}
			if (cred != _cred) debug1("+ cred=[%s]", cred)
		}

		if (data_mode) {
			rw_rate = cred_rw / time_delta
		}

		if (meta_mode) {
			total_rate = cred_total / time_delta
		}
		if (output_json) {
			# ST: JSONDATA
			json_out = ""
			json_out = json_add_uint(json_out, "time", tm)
			json_out = json_add_str(json_out, "ident", curview)
			if (redact && curview == "user") {
				if (cred !~ unredacted_users)
					cred = get_random(length(cred))
			} else if (redact && curview == "group") {
				if (cred !~ unredacted_groups)
					cred = get_random(length(cred))
			} else if (redact && curview == "client") {
				if (cred !~ unredacted_clients)
					cred = get_random(length(cred))
			} else if (redact && curview == "server") {
				if (cred !~ unredacted_servers)
					cred = get_random(length(cred))
			} else if (redact && curview == "file") {
				if (cred !~ unredacted_files)
					cred = get_random(length(cred))
			}
			json_out = json_add_str(json_out, curview, cred)
			if (data_mode) {
				json_out = json_add_uint(json_out,
					"total_bytes", cred_rw)
				json_out = json_add_float(json_out,
					"total_rate", rw_rate)
				json_out = json_add_uint(json_out,
					"read_bytes", cred_read)
				json_out = json_add_float(json_out,
					"read_rate", read_rate)
				json_out = json_add_uint(json_out,
					"write_bytes", cred_write)
				json_out = json_add_float(json_out,
					"write_rate", write_rate)
			}
			if (meta_mode) {
				json_out = json_add_uint(json_out,
					"stat_total", cred_total)
				json_out = json_add_float(json_out,
					"stat_rate", total_rate)
				json_out = json_add_uint(json_out,
					"stat_good_total", cred_good)
				json_out = json_add_float(json_out,
					"stat_good_rate", good_rate)
				if (fstype == "*" ||
				    (curview == "type" && cred == "*")) {
					json_out = json_add_uint(json_out,
						"stat_fail_total", cred_fail)
					json_out = json_add_float(json_out,
						"stat_fail_rate", fail_rate)
				}
			}
			buffer_add("{" json_out "}\n")
		} else if (show_basic && mode == "data") {
			# ST: VIEWDATA
			buffer_add1(cred,
				humanize(cred_rw),
				humanize(cred_read), read_bar,
				write_bar, humanize(cred_write))
		} else if (show_basic && mode == "meta") {
			# ST: VIEWDATA
			buffer_add1(cred,
				humanize(cred_total),
				humanize(cred_good), good_bar,
				fail_bar, humanize(cred_fail))
		} else if (mode == "data") {
			# ST: VIEWDATA
			buffer_add1(cred,
				humanize(rw_rate),
				humanize(read_rate), read_bar,
				write_bar, humanize(write_rate))
		} else if (mode == "meta") {
			# ST: VIEWDATA
			buffer_add1(cred,
				humanize(total_rate),
				humanize(good_rate), good_bar,
				fail_bar, humanize(fail_rate))
		}

		return 1
	}

	######################################## MAIN

	sub(/^EXIT:/, "") { exit_status = $0; next }
	debug { sub(/^\t/, ""); print; next }

	raw_view {
		print

		# Exit if no more samples desired
		if (/^---$/) sample_check()

		if (!debugger) next
	}

	#
	# ST: TRACEDATA
	#

	/^===/ { # Data start
		if (data_mode) {
			read_total = write_total = 0
		}
		if (meta_mode) {
			stat_good_total = stat_fail_total = 0
		}
		clear_data()
		clear_buffer()
		next
	}

	/^@/ { parse_map(); next } # Data

	/^---$/ { # Data end
		buffer_add_data()

		#
		# Dump information
		#
		print_buffer()
		sample_check() # Exit if no more samples desired
		next
	}

	#
	# ST: CALLS
	#

	{ call = "" }

	match($0, /^[_a-z]+(-[_a-z]+)?\|/) {
		call = substr($0, 1, RLENGTH - 1)
		$0 = substr($0, RSTART + RLENGTH)
	}

	call == "info" { if (!output_json) info($0) }
	call == "init" { bpftrace_init() }

	call == "resize" {
		if (output_json) next
		rows = $1
		cols = $2
		resize()
	}

	call == "time" {
		times[1] = times[2]
		times[2] = tm = $0
	}

	################################################## END

	END { exit exit_status }
' # END-QUOTE

################################################################################
# END
################################################################################
# Local Variables:
# mode: sh
# tab-width: 8
# sh-basic-offset: 8
# indent-tabs-mode: t
# backward-delete-char-untabify-method: nil
# End:
